<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WhatsApp Bulk Messenger</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: #128C7E;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        h2 {
            color: #075E54;
            margin-top: 30px;
            font-size: 1.3rem;
            font-weight: 500;
        }
        .container {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        #qr-container {
            text-align: center;
            display: none;
            margin: 20px 0;
        }
        #qr-code {
            width: 256px;
            height: 256px;
            margin: 0 auto;
            display: block;
        }
        .status {
            background-color: #f8f9fa;
            border-left: 4px solid #ffc107;
            padding: 10px 15px;
            margin: 15px 0;
            border-radius: 0 4px 4px 0;
        }
        .status.success {
            border-left-color: #28a745;
        }
        .status.error {
            border-left-color: #dc3545;
        }
        button {
            background-color: #128C7E;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #075E54;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #logout-btn {
            background-color: #e74c3c;
            margin-left: 10px;
            display: none;
        }
        #logout-btn:hover {
            background-color: #c0392b;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        input[type="file"], textarea {
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px;
        }
        textarea {
            height: 100px;
            resize: vertical;
        }
        #message-form {
            display: none;
        }
        #results {
            display: none;
            margin-top: 20px;
        }
        .results-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 4px;
        }
        .status-item {
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        .success-item {
            color: #28a745;
            border-left: 3px solid #28a745;
            padding-left: 5px;
        }
        .failed-item {
            color: #dc3545;
            border-left: 3px solid #dc3545;
            padding-left: 5px;
        }
        .scheduled-item {
            color: #6c757d;
            border-left: 3px solid #6c757d;
            padding-left: 5px;
        }
        .pending-item {
            color: #ffc107;
            border-left: 3px solid #ffc107;
            padding-left: 5px;
        }
        /* Progress bar */
        #progress-container {
            display: none;
            margin-top: 20px;
        }
        .progress-bar-container {
            width: 100%;
            height: 20px;
            background-color: #f1f1f1;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        .progress-bar {
            height: 100%;
            background-color: #4CAF50;
            text-align: center;
            color: white;
            line-height: 20px;
            transition: width 0.5s;
        }
        .summary {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .summary-item {
            text-align: center;
            flex: 1;
            min-width: 100px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            margin: 0 5px 10px 5px;
        }
        .summary-item h3 {
            margin: 0;
            font-size: 14px;
            color: #6c757d;
        }
        .summary-item p {
            margin: 5px 0 0 0;
            font-size: 24px;
            font-weight: bold;
        }
        .status-lists {
            display: flex;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .status-column {
            flex: 1;
            min-width: 300px;
            margin: 0 5px 10px 5px;
        }
        .status-column h3 {
            color: #6c757d;
            font-size: 16px;
            margin-top: 0;
            margin-bottom: 10px;
        }
        .scheduled-column {
            flex: 1;
            min-width: 300px;
            margin: 0 5px 10px 5px;
            display: none;
        }
        /* Toggle Switch */
        .toggle-container {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        .toggle-label {
            margin-left: 10px;
            font-weight: normal;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            border-radius: 24px;
            transition: .4s;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: .4s;
        }
        input:checked + .toggle-slider {
            background-color: #128C7E;
        }
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        /* Schedule display */
        .schedule-container {
            display: none;
            margin-top: 20px;
            background-color: #f8f9fa;
            border-radius: 4px;
            padding: 15px;
            border: 1px solid #dee2e6;
        }
        .schedule-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .schedule-header h3 {
            margin: 0;
            color: #075E54;
        }
        .schedule-next {
            font-size: 16px;
            font-weight: 500;
            color: #333;
            margin-bottom: 15px;
        }
        .time-progress-container {
            height: 6px;
            background-color: #e9ecef;
            border-radius: 3px;
            margin-bottom: 5px;
            overflow: hidden;
        }
        .time-progress {
            height: 100%;
            background-color: #17a2b8;
            transition: width 1s;
        }
        .time-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #6c757d;
        }
        /* Message input area */
        .message-input-area {
            margin-top: 10px;
            margin-bottom: 20px;
        }
        /* Scheduled Messages section */
        .card {
            margin-top: 20px;
        }
        .card-header {
            background-color: #f8f9fa;
            border-bottom: none;
        }
        .card-body {
            padding: 20px;
        }
        .scheduled-messages-list {
            margin-bottom: 20px;
        }
        .schedule-visualization {
            margin-top: 15px;
            margin-bottom: 15px;
            position: relative;
        }
        #scheduleTimeline {
            height: 70px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            background-color: #fcfcfc;
        }
        #messagePoints {
            position: absolute;
            top: 21px;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 2;
            background-color: rgba(255, 255, 255, 0.2);
        }
        .message-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: #007bff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
            transition: transform 0.2s ease-in-out;
        }
        .message-dot:hover {
            transform: translate(-50%, -50%) scale(1.5);
            background-color: #0056b3;
            z-index: 10;
            cursor: pointer;
        }
        .schedule-stats {
            margin-top: 10px;
        }
        .next-message {
            font-size: 16px;
            font-weight: 500;
            color: #333;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #e9f7fb;
            border-left: 4px solid #17a2b8;
            border-radius: 4px;
        }
        
        .next-message-container {
            margin-bottom: 20px;
        }
        
        .next-message-title {
            font-size: 15px;
            color: #555;
            margin-bottom: 8px;
        }
        /* CSS styles for upcoming messages */
        .upcoming-messages-container {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            background-color: #ffffff;
            display: block !important;
            width: 100%;
        }
        .upcoming-messages-title {
            font-size: 15px;
            color: #555;
            margin-bottom: 12px;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }
        .upcoming-messages-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
        }
        
        .upcoming-messages-table {
            font-size: 0.9rem;
            margin-bottom: 0;
        }
        
        .upcoming-messages-table th,
        .upcoming-messages-table td {
            padding: 4px 8px;
            vertical-align: middle;
        }
        
        .next-message-info {
            padding: 10px;
            background-color: #f8f9fa;
            border-left: 4px solid #17a2b8;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        
        .status-item {
            padding: 8px 10px;
            margin-bottom: 4px;
            border-radius: 4px;
            font-size: 0.9rem;
            animation: fadeIn 0.3s ease-in;
        }
        
        .success-item {
            background-color: rgba(40, 167, 69, 0.1);
            border-left: 3px solid #28a745;
        }
        
        .failed-item {
            background-color: rgba(220, 53, 69, 0.1);
            border-left: 3px solid #dc3545;
        }
        
        .scheduled-item {
            background-color: rgba(108, 117, 125, 0.1);
            border-left: 3px solid #6c757d;
        }
        
        .status-list {
            max-height: 300px;
            overflow-y: auto;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Add pulse animation for active processing */
        .processing-active {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        .time-stamp {
            color: #6c757d;
            font-size: 0.85em;
        }
        
        .upcoming-message-row {
            transition: background-color 0.5s ease;
        }
        
        .upcoming-message-row.imminent {
            background-color: rgba(255, 193, 7, 0.2);
            font-weight: bold;
        }
        
        .upcoming-message-row.very-soon {
            background-color: rgba(23, 162, 184, 0.1);
        }
        
        .pulse {
            animation: pulse-animation 2s infinite;
        }
        
        @keyframes pulse-animation {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        /* Upcoming messages table styling */
        .upcoming-messages-table {
            margin-bottom: 0;
        }
        
        .upcoming-message-row {
            transition: background-color 0.3s ease;
        }
        
        .upcoming-message-row.imminent {
            background-color: rgba(255, 193, 7, 0.3) !important;
            font-weight: bold;
        }
        
        .upcoming-message-row.very-soon {
            background-color: rgba(23, 162, 184, 0.1) !important;
        }
        
        .pulse {
            animation: pulse-animation 1.5s infinite;
        }
        
        @keyframes pulse-animation {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .countdown-cell {
            font-family: monospace;
        }
        
        /* Function to update the next message countdown has been moved to the main JavaScript section */
        
        /* Add these styles for better real-time visual cues */
        .pulse-strong {
            animation: pulse-animation 1s infinite;
            color: #dc3545;
            font-weight: bold;
        }
        
        .next-message-info {
            padding: 10px 15px;
            background-color: #f8f9fa;
            border-left: 4px solid #17a2b8;
            margin-bottom: 15px;
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }
        
        .next-message-info.imminent {
            background-color: rgba(255, 193, 7, 0.2);
            border-left-color: #ffc107;
        }
        
        /* Improve table readability */
        .upcoming-messages-table th {
            background-color: #f8f9fa;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        /* Improve animation performance */
        .countdown-cell, .upcoming-message-row {
            will-change: background-color, opacity;
        }
        
        /* Ensure scheduled info sections are always visible when they contain data */
        #scheduled-info {
            display: block !important;
        }
        
        .all-messages-status {
            display: block !important;
        }
        
        #upcoming-messages-list {
            display: block !important;
            min-height: 50px;
        }
        
        /* Styling for the currently processing number */
        .current-processing-number {
            font-weight: bold;
            color: #128C7E;
            padding: 2px 8px;
            border-radius: 4px;
            background-color: rgba(18, 140, 126, 0.1);
            display: inline-block;
            animation: processing-pulse 1.5s infinite;
            font-size: 1.1em;
            border-left: 3px solid #128C7E;
        }
        
        /* Different status styles */
        .current-processing-number.processing-active {
            color: #128C7E; /* WhatsApp green */
            background-color: rgba(18, 140, 126, 0.1);
            border-left-color: #128C7E;
            animation: processing-pulse 1.5s infinite;
        }
        
        .current-processing-number.next-active {
            color: #0D7377; /* Teal */
            background-color: rgba(13, 115, 119, 0.1);
            border-left-color: #0D7377;
            animation: none;
        }
        
        .current-processing-number.scheduled-active {
            color: #6C757D; /* Gray */
            background-color: rgba(108, 117, 125, 0.1);
            border-left-color: #6C757D;
            animation: none;
        }
        
        .current-processing-number.imminent-active {
            color: #FF9800; /* Orange */
            background-color: rgba(255, 152, 0, 0.1);
            border-left-color: #FF9800;
            animation: processing-pulse 1s infinite;
        }
        
        .current-processing-number.completed-active {
            color: #28A745; /* Success green */
            background-color: rgba(40, 167, 69, 0.1);
            border-left-color: #28A745;
            animation: none;
        }
        
        .processing-active {
            font-weight: 500;
        }
        
        @keyframes processing-pulse {
            0% { 
                background-color: rgba(18, 140, 126, 0.1);
                box-shadow: 0 0 0 0 rgba(18, 140, 126, 0.5);
            }
            50% { 
                background-color: rgba(18, 140, 126, 0.2);
                box-shadow: 0 0 0 5px rgba(18, 140, 126, 0.1);
            }
            100% { 
                background-color: rgba(18, 140, 126, 0.1);
                box-shadow: 0 0 0 0 rgba(18, 140, 126, 0.5);
            }
        }
        
        /* Increase the prominence of the current number display */
        .current-number {
            font-size: 1.1em;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #128C7E;
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>WhatsApp Bulk Messenger</h1>
        
        <div class="instruction">
            <p><strong>Instructions:</strong></p>
            <ol>
                <li>Click "Connect WhatsApp" and scan the QR code with your WhatsApp mobile app</li>
                <li>Upload a text file with one phone number per line (with country code, e.g., 12345678901)</li>
                <li>Enter the message you want to send to all numbers</li>
                <li>Click "Send Messages" to start sending</li>
            </ol>
        </div>

        <div id="connection-section">
            <button id="connect-btn">Connect WhatsApp</button>
            <button id="logout-btn" style="display: none; background-color: #e74c3c;">Logout</button>
            <div class="status" id="status-message">Not connected</div>
            <div class="qr-container" id="qr-container">
                <p>Scan this QR code with your WhatsApp:</p>
                <img id="qr-code" class="qr-code" src="" alt="QR Code">
            </div>
        </div>

        <form id="message-form" style="display: none;" enctype="multipart/form-data">
            <div class="form-group">
                <label for="numbersFile">Upload file with phone numbers (one per line):</label>
                <input type="file" id="numbersFile" name="numbersFile" accept=".txt" required>
            </div>
            <div class="form-group">
                <label for="message">Message to send:</label>
                <textarea id="message" name="message" placeholder="Enter your message here..." required></textarea>
            </div>
            <div class="toggle-container">
                <label class="toggle-switch">
                    <input type="checkbox" id="schedule-toggle" name="useSchedule" value="true">
                    <span class="toggle-slider"></span>
                </label>
                <span class="toggle-label">Spread messages over time to avoid spam detection</span>
            </div>
            
            <!-- Simplified Schedule Options -->
            <div id="custom-schedule-options" style="display: none; margin-top: 15px; padding: 15px; background-color: #f8f9fa; border-radius: 4px; border: 1px solid #dee2e6;">
                <h4 style="margin-top: 0; color: #075E54; font-size: 16px;">Schedule Duration</h4>
                
                <div class="form-group">
                    <label for="schedule-duration">Duration (hours):</label>
                    <input type="number" id="schedule-duration" name="scheduleDuration" min="1" max="168" value="24" class="form-control" title="Messages will be randomly distributed within this time period">
                    <small class="form-text text-muted">All messages will be sent at random times within the specified period. Enter 1 hour for quick delivery or up to 168 hours (1 week) for maximum spreading.</small>
                </div>
                
                <div class="alert alert-info" style="font-size: 14px; margin-top: 10px;">
                    <strong>Tips to avoid spam detection:</strong>
                    <ul style="margin-top: 5px; padding-left: 20px;">
                        <li>Spreading messages over 24 hours is recommended for large batches</li>
                        <li>For urgent messages, use a shorter duration (1-6 hours)</li>
                        <li>All messages will be sent regardless of quantity</li>
                        <li>Avoid repetitive or promotional language in your messages</li>
                    </ul>
                </div>
            </div>
            <!-- End of Simplified Schedule Options -->
            
            <button type="submit" id="send-btn">Send Messages</button>
        </form>

        <div class="progress-container" id="progress-container" style="display: none;">
            <div class="current-number" id="current-number">Processing: None</div>
            
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar">0%</div>
            </div>
            
            <div class="status-header">
                <span id="progress-text">0/0 (0%)</span>
            </div>
            
            <div class="summary">
                <div class="summary-item">
                    <div class="summary-number total" id="total-count">0</div>
                    <div class="summary-label">Total</div>
                </div>
                <div class="summary-item">
                    <div class="summary-number success" id="success-count">0</div>
                    <div class="summary-label">Success</div>
                </div>
                <div class="summary-item">
                    <div class="summary-number error" id="failed-count">0</div>
                    <div class="summary-label">Failed</div>
                </div>
                <div class="summary-item">
                    <div class="summary-number scheduled" id="scheduled-count">0</div>
                    <div class="summary-label">Scheduled</div>
                </div>
            </div>
            
            <div id="scheduled-info" style="display: none;">
                <h3>Scheduled Messages Status</h3>
                <div class="next-message-info" id="next-message">Next message in: --:--:--</div>
                
                <!-- Add new section for real-time status of all messages -->
                <div class="all-messages-status mt-3">
                    <h4>All Upcoming Messages</h4>
                    <div id="upcoming-messages-list" class="upcoming-messages-list">
                        <div class="text-muted">No scheduled messages</div>
                    </div>
                </div>
                
                <div class="schedule-progress mt-3">
                    <div class="d-flex justify-content-between">
                        <span id="start-time">Start</span>
                        <span id="end-time">End</span>
                    </div>
                    <div class="progress-bar-container">
                        <div id="time-progress" class="progress-bar"></div>
                </div>
                    <div class="mt-2 text-center">
                        <button id="stop-schedule-btn" class="btn btn-sm btn-danger">Stop Schedule</button>
                    </div>
                </div>
            </div>
            
            <div class="status-lists">
                <div class="status-column">
                    <div class="list-title success">Success</div>
                    <div class="status-list" id="success-list"></div>
                </div>
                <div class="status-column">
                    <div class="list-title error">Failed</div>
                    <div class="status-list" id="failed-list"></div>
                </div>
                <div class="status-column" id="scheduled-column" style="display: none;">
                    <div class="list-title scheduled">Scheduled</div>
                    <div class="status-list" id="scheduled-list"></div>
                </div>
            </div>
        </div>

        <div class="results" id="results">
            <h3>Results:</h3>
            <div id="results-content"></div>
        </div>

        <!-- Scheduled Messages section -->
        <div class="card mt-3" id="scheduledMessagesCard" style="display: none;">
            <div class="card-header bg-primary text-white">
                <h5 class="mb-0">Scheduled Messages</h5>
            </div>
            <div class="card-body">
                <div class="scheduled-controls mb-3">
                    <button id="refreshScheduleBtn" class="btn btn-sm btn-outline-primary">Refresh List</button>
                    <span id="scheduledMessagesCount" class="badge bg-primary ml-2">0</span> messages scheduled
                </div>
                
                <div id="scheduledMessagesList" class="scheduled-messages-list">
                    <!-- Messages will be added here dynamically -->
                    <div class="text-center text-muted">No scheduled messages</div>
                </div>
                
                <!-- Timeline visualization for scheduled messages -->
                <div class="mt-4">
                    <h6>Sending Schedule Timeline</h6>
                    <div class="schedule-visualization mb-3">
                        <div id="scheduleTimeline" class="position-relative" style="height: 70px; border: 1px solid #ddd; border-radius: 4px; overflow: hidden;">
                            <!-- Time markers -->
                            <div class="d-flex justify-content-between" style="position: absolute; top: 0; left: 0; right: 0; height: 20px; background-color: #f8f9fa; border-bottom: 1px solid #ddd;">
                                <span class="px-1">00:00</span>
                                <span class="px-1">06:00</span>
                                <span class="px-1">12:00</span>
                                <span class="px-1">18:00</span>
                                <span class="px-1">24:00</span>
                            </div>
                            <!-- Message dots will be added here by JavaScript -->
                            <div id="messagePoints" class="position-absolute" style="top: 21px; bottom: 0; left: 0; right: 0;"></div>
                        </div>
                    </div>
                    <div class="d-flex justify-content-between schedule-stats mt-2">
                        <div><small>Morning: <span id="morningCount">0</span> messages</small></div>
                        <div><small>Afternoon: <span id="afternoonCount">0</span> messages</small></div>
                        <div><small>Evening: <span id="eveningCount">0</span> messages</small></div>
                        <div><small>Night: <span id="nightCount">0</span> messages</small></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const connectBtn = document.getElementById('connect-btn');
            const logoutBtn = document.getElementById('logout-btn');
            const qrContainer = document.getElementById('qr-container');
            const qrCode = document.getElementById('qr-code');
            const statusMessage = document.getElementById('status-message');
            const messageForm = document.getElementById('message-form');
            const resultsDiv = document.getElementById('results');
            const resultsContent = document.getElementById('results-content');
            
            // Progress elements
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            const currentNumber = document.getElementById('current-number');
            const totalCount = document.getElementById('total-count');
            const successCount = document.getElementById('success-count');
            const failedCount = document.getElementById('failed-count');
            const scheduledCount = document.getElementById('scheduled-count');
            const successList = document.getElementById('success-list');
            const failedList = document.getElementById('failed-list');
            const scheduledList = document.getElementById('scheduled-list');
            
            // Schedule elements
            const scheduleToggle = document.getElementById('schedule-toggle');
            const scheduledColumn = document.getElementById('scheduled-column');
            const nextMessage = document.getElementById('next-message');
            const timeProgress = document.getElementById('time-progress');
            const startTime = document.getElementById('start-time');
            const endTime = document.getElementById('end-time');
            const stopScheduleBtn = document.getElementById('stop-schedule-btn');
            
            // Scheduled messages management elements
            const scheduledMessagesCard = document.getElementById('scheduledMessagesCard');
            const scheduledMessagesList = document.getElementById('scheduledMessagesList');
            const scheduledMessagesCount = document.getElementById('scheduledMessagesCount');
            const refreshScheduleBtn = document.getElementById('refreshScheduleBtn');
            const messagePoints = document.getElementById('messagePoints');
            const morningCount = document.getElementById('morningCount');
            const afternoonCount = document.getElementById('afternoonCount');
            const eveningCount = document.getElementById('eveningCount');
            const nightCount = document.getElementById('nightCount');
            
            // Flag to control message sending
            let isAborted = false;
            let isScheduleMode = false;
            let statusUpdateInterval = null;
            let scheduleChecked = false; // Flag to track if we've checked for scheduled messages

            // Add persistence flag
            let processingActive = false;

            // Check for active processes immediately when page loads
            checkActiveProcessesOnLoad();

            // Function to check for active processes when page loads
            async function checkActiveProcessesOnLoad() {
                console.log('Checking for active processes on page load...');
                
                // First attempt to restore data from localStorage
                const storedData = localStorage.getItem('sendingResults');
                const lastUpdate = localStorage.getItem('lastStatusUpdate');
                const now = new Date().getTime();
                
                // Check if we have recent stored data (within the last 2 minutes)
                if (storedData && lastUpdate && (now - parseInt(lastUpdate) < 120000)) {
                    console.log('Restoring state from localStorage');
                    
                    try {
                        // Parse the stored data
                        const data = JSON.parse(storedData);
                        
                        // Show progress container to make everything visible
                        progressContainer.style.display = 'block';
                        
                        // Restore current number if available
                        if (data.current) {
                            // Parse the current number
                            let displayNumber = '';
                            let statusPrefix = '';
                            
                            if (data.current.includes(':')) {
                                const parts = data.current.split(':');
                                statusPrefix = parts[0].trim();
                                let remaining = parts[1].trim();
                                if (remaining.includes('(')) {
                                    displayNumber = remaining.substring(0, remaining.indexOf('(')).trim();
                                } else {
                                    displayNumber = remaining;
                                }
                            } else {
                                displayNumber = data.current;
                                statusPrefix = 'Processing';
                            }
                            
                            // Apply appropriate styling based on status prefix
                            let statusClass = '';
                            switch (statusPrefix.toLowerCase()) {
                                case 'processing':
                                    statusClass = 'processing-active';
                                    break;
                                case 'next':
                                    statusClass = 'next-active';
                                    break;
                                case 'scheduled':
                                    statusClass = 'scheduled-active';
                                    break;
                                case 'processing soon':
                                    statusClass = 'imminent-active';
                                    break;
                                case 'completed':
                                    statusClass = 'completed-active';
                                    break;
                                default:
                                    statusClass = 'processing-active';
                            }
                            
                            // Update the UI
                            currentNumber.innerHTML = `${statusPrefix}: <span class="current-processing-number ${statusClass}">${displayNumber}</span>`;
                            currentNumber.classList.add('processing-active');
                        }
                        
                        // Restore counts
                        totalCount.textContent = data.total || '0';
                        successCount.textContent = data.success ? data.success.length : '0';
                        failedCount.textContent = data.failed ? data.failed.length : '0';
                        
                        // Restore progress
                        if (data.total > 0) {
                            const progress = Math.round((data.processed / data.total) * 100) || 0;
                            progressBar.style.width = `${progress}%`;
                            progressBar.textContent = `${progress}%`;
                            progressText.textContent = `${data.processed}/${data.total} (${progress}%)`;
                        }
                        
                        // Restore success/failed lists
                        updateStatusLists(data);
                        
                        // If scheduling info exists, restore scheduled messages and upcoming list
                        if (data.scheduleInfo) {
                            // Show scheduled info section
                            document.getElementById('scheduled-info').style.display = 'block';
                            
                            // Make scheduled column visible
                            const scheduledColumn = document.getElementById('scheduled-column');
                            if (scheduledColumn) scheduledColumn.style.display = 'block';
                            
                            // Create schedule display data from the stored data
                            const scheduleDisplayData = {
                                active: true,
                                startTime: data.scheduleInfo.startTime,
                                endTime: data.scheduleInfo.endTime,
                                upcomingMessages: data.scheduleInfo.upcomingMessages || []
                            };
                            
                            // Update the schedule display
                            updateScheduleDisplay(scheduleDisplayData);
                            
                            // Update upcoming messages list
                            if (data.scheduleInfo.upcomingMessages && data.scheduleInfo.upcomingMessages.length > 0) {
                                updateUpcomingMessagesList(data.scheduleInfo.upcomingMessages);
                            }
                            
                            // Update scheduled count
                            if (data.scheduled) {
                                const scheduledItems = data.scheduled.filter(item => item.status === 'scheduled');
                                scheduledCount.textContent = scheduledItems.length;
                            }
                        }
                        
                        // Show the message form if processing is complete, otherwise hide it
                        if (data.processed >= data.total) {
                            messageForm.style.display = 'block';
                        } else {
                            messageForm.style.display = 'none';
                            // Start polling for updates if processing is still ongoing
                            startStatusPolling();
                        }
                        
                        // If we have data in localStorage, prioritize that and return
                        // We'll still check the server in the background
                        console.log('Successfully restored state from localStorage');
                    } catch (error) {
                        console.error('Error parsing localStorage data:', error);
                    }
                }
                
                try {
                    // Check if WhatsApp is connected
                    const sessionResponse = await fetch('/check-session');
                    const sessionData = await sessionResponse.json();
                    
                    if (sessionData.status === 'connected') {
                        console.log('WhatsApp is connected, checking for active processes...');
                        
                        // Check for active processes first to get the current processing number
                        const statusResponse = await fetch('/message-status');
                        if (statusResponse.ok) {
                            const data = await statusResponse.json();
                            console.log('Current message status:', data);
                            
                            // Store the data in localStorage for persistence
                            localStorage.setItem('sendingResults', JSON.stringify(data));
                            localStorage.setItem('lastStatusUpdate', new Date().getTime());
                            
                            // If there are active processes or scheduled messages, show the progress UI
                            if (data.total > 0 || 
                                (data.scheduleInfo && data.scheduleInfo.upcomingMessages && data.scheduleInfo.upcomingMessages.length > 0) ||
                                (data.success && data.success.length > 0) || 
                                (data.failed && data.failed.length > 0)) {
                                
                                // Hide message form and show progress
                                statusMessage.style.display = 'none';
                                messageForm.style.display = 'none';
                                progressContainer.style.display = 'block';
                                
                                // Update all counters
                                totalCount.textContent = data.total || '0';
                                successCount.textContent = data.success ? data.success.length : '0';
                                failedCount.textContent = data.failed ? data.failed.length : '0';
                                
                                // Show success and failure columns if they have data
                                if (data.success && data.success.length > 0) {
                                    const successColumn = document.getElementById('success-column');
                                    if (successColumn) successColumn.style.display = 'block';
                                }
                                
                                if (data.failed && data.failed.length > 0) {
                                    const failedColumn = document.getElementById('failed-column');
                                    if (failedColumn) failedColumn.style.display = 'block';
                                }
                                
                                // If we have a current number, update the UI
                                if (data.current) {
                                    // Parse the current number and status
                                    let displayNumber = '';
                                    let statusPrefix = '';
                                    
                                    if (data.current.includes(':')) {
                                        const parts = data.current.split(':');
                                        statusPrefix = parts[0].trim();
                                        let remaining = parts[1].trim();
                                        if (remaining.includes('(')) {
                                            displayNumber = remaining.substring(0, remaining.indexOf('(')).trim();
                                        } else {
                                            displayNumber = remaining;
                                        }
                                    } else {
                                        displayNumber = data.current;
                                        statusPrefix = 'Processing';
                                    }
                                    
                                    // Apply appropriate styling based on status prefix
                                    let statusClass = '';
                                    switch (statusPrefix.toLowerCase()) {
                                        case 'processing':
                                            statusClass = 'processing-active';
                                            break;
                                        case 'next':
                                            statusClass = 'next-active';
                                            break;
                                        case 'scheduled':
                                            statusClass = 'scheduled-active';
                                            break;
                                        case 'processing soon':
                                            statusClass = 'imminent-active';
                                            break;
                                        case 'completed':
                                            statusClass = 'completed-active';
                                            break;
                                        default:
                                            statusClass = 'processing-active';
                                    }
                                    
                                    // Update the UI with current number
                                    currentNumber.innerHTML = `${statusPrefix}: <span class="current-processing-number ${statusClass}">${displayNumber}</span>`;
                                    currentNumber.classList.add('processing-active');
                                }
                                
                                // If scheduling is active, show scheduled info
                                if (data.scheduleInfo) {
                                    // Always show scheduled info section
                                    document.getElementById('scheduled-info').style.display = 'block';
                                    
                                    // Make scheduled column visible
                                    const scheduledColumn = document.getElementById('scheduled-column');
                                    if (scheduledColumn) scheduledColumn.style.display = 'block';
                                    
                                    // Update scheduled count
                                    const scheduledItems = data.scheduled ? data.scheduled.filter(item => item.status === 'scheduled') : [];
                                    scheduledCount.textContent = scheduledItems.length;
                                    
                                    // Create an object with properties needed by updateScheduleDisplay
                                    const scheduleDisplayData = {
                                        active: true, // Force active state
                                        startTime: data.scheduleInfo.startTime,
                                        endTime: data.scheduleInfo.endTime,
                                        upcomingMessages: data.scheduleInfo.upcomingMessages || []
                                    };
                                    
                                    // Update schedule display immediately
                                    updateScheduleDisplay(scheduleDisplayData);
                                    
                                    // Force update of upcoming messages list
                                    if (data.scheduleInfo.upcomingMessages && data.scheduleInfo.upcomingMessages.length > 0) {
                                        updateUpcomingMessagesList(data.scheduleInfo.upcomingMessages);
                                    }
                                } else {
                                    // Standard mode
                                    scheduledCount.textContent = data.processed < data.total ? (data.total - data.processed) : '0';
                                    
                                    // Update progress bar
                                    const progress = Math.round((data.processed / data.total) * 100) || 0;
                                    progressBar.style.width = `${progress}%`;
                                    progressBar.textContent = `${progress}%`;
                                    progressText.textContent = `${data.processed}/${data.total} (${progress}%)`;
                                }
                                
                                // Update status lists
                                updateStatusLists(data);
                                
                                // Start polling for updates
                                startStatusPolling();
                                
                                console.log('Active process detected, UI restored and real-time updates started');
                            }
                        }
                        
                        // If we're here but no active processes found, check for scheduled messages
                        const scheduledResponse = await fetch('/scheduled-messages');
                        if (scheduledResponse.ok) {
                            const scheduledData = await scheduledResponse.json();
                            
                            // Show scheduled messages even if they're not currently "active"
                            if (scheduledData.messages && scheduledData.messages.length > 0) {
                                console.log('Found scheduled messages, displaying in real-time');
                                
                                // Show progress container
                                progressContainer.style.display = 'block';
                                
                                // Make the scheduled info section visible
                                document.getElementById('scheduled-info').style.display = 'block';
                                
                                // Display scheduled messages card
                                const scheduledMessagesCard = document.getElementById('scheduledMessagesCard');
                                if (scheduledMessagesCard) scheduledMessagesCard.style.display = 'block';
                                
                                // Display scheduled messages
                                displayScheduledMessages(scheduledData);
                                
                                // Make sure the upcoming messages are shown
                                updateUpcomingMessagesList(scheduledData.messages);
                                
                                // Create schedule display data
                                const scheduleDisplayData = {
                                    active: true,
                                    startTime: scheduledData.startTime,
                                    endTime: scheduledData.endTime,
                                    upcomingMessages: scheduledData.messages
                                };
                                
                                // Update schedule display
                                updateScheduleDisplay(scheduleDisplayData);
                                
                                // Start polling for updates if not already started
                                if (!statusUpdateInterval) {
                                    startStatusPolling();
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error checking for active processes:', error);
                }
            }
            
            // Function to check if there's an active processing task
            async function checkProcessingStatus() {
                try {
                    const response = await fetch('/message-status');
                    if (!response.ok) {
                        return false;
                    }
                    
                    const data = await response.json();
                    console.log('Current status data:', data);
                    
                    // Check if there's an active process (has total count and is not complete)
                    const isActive = data.total > 0 && data.processed < data.total;
                    
                    if (isActive) {
                        console.log('Active processing detected:', data.processed, 'of', data.total);
                        
                        // Update all UI elements with current status
                        totalCount.textContent = data.total;
                        successCount.textContent = data.success.length;
                        failedCount.textContent = data.failed.length;
                        
                        // Update current processing status
                        if (data.current) {
                            currentNumber.textContent = `Processing: ${data.current}`;
                        } else {
                            currentNumber.textContent = `Processing: Waiting for next message`;
                        }
                        
                        // Update progress bar
                        const progress = Math.round((data.processed / data.total) * 100) || 0;
                        progressBar.style.width = `${progress}%`;
                        progressBar.textContent = `${progress}%`;
                        progressText.textContent = `${data.processed}/${data.total} (${progress}%)`;
                        
                        // If we have scheduling info, update schedule display
                        if (data.scheduleInfo) {
                            updateScheduleDisplay(data);
                            document.getElementById('scheduled-info').style.display = 'block';
                        }
                        
                        // Update status lists
                        updateStatusLists(data);
                        
                        // Update scheduled count
                        if (data.scheduleInfo) {
                            const scheduledItems = data.scheduled.filter(item => item.status === 'scheduled');
                            scheduledCount.textContent = scheduledItems.length;
                        } else {
                            scheduledCount.textContent = data.total - data.processed;
                        }
                    }
                    
                    return isActive;
                } catch (error) {
                    console.error('Error checking processing status:', error);
                    return false;
                }
            }
            
            // Fetch and display scheduled messages
            async function fetchScheduledMessages() {
                try {
                    console.log('Fetching scheduled messages...');
                    const response = await fetch('/scheduled-messages');
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error('Server error fetching scheduled messages:', errorData);
                        throw new Error(errorData.error || 'Failed to fetch scheduled messages');
                    }
                    
                    const data = await response.json();
                    console.log('Scheduled messages API response:', data);
                    
                    if (!data.messages || !Array.isArray(data.messages)) {
                        console.warn('Invalid data format for scheduled messages:', data);
                        return { total: 0, messages: [] };
                    }
                    
                    // Ensure the progress container and scheduled info are visible
                    progressContainer.style.display = 'block';
                    document.getElementById('scheduled-info').style.display = 'block';
                    
                    // Ensure the timeline is properly populated
                    if (data.messages.length > 0) {
                        const scheduleTimeline = document.getElementById('scheduleTimeline');
                        const messagePoints = document.getElementById('messagePoints');
                        
                        if (scheduleTimeline && messagePoints) {
                            scheduleTimeline.style.display = 'block';
                            console.log(`Timeline container dimensions: ${scheduleTimeline.offsetWidth}x${scheduleTimeline.offsetHeight}`);
                        }
                        
                        // Force update of the upcoming messages list
                        updateUpcomingMessagesList(data.messages);
                        
                        // Prepare data format expected by updateScheduleDisplay
                        const scheduleDisplayData = {
                            active: true, // Force active state
                            startTime: data.startTime,
                            endTime: data.endTime,
                            upcomingMessages: data.messages
                        };
                        
                        // Update the schedule display
                        updateScheduleDisplay(scheduleDisplayData);
                    }
                    
                    // Display the scheduled messages
                    displayScheduledMessages(data);
                    
                    // Make the scheduled messages card visible if we have messages
                    if (data.total > 0) {
                        const scheduledMessagesCard = document.getElementById('scheduledMessagesCard');
                        if (scheduledMessagesCard) {
                            scheduledMessagesCard.style.display = 'block';
                        }
                    }
                    
                    // If the status polling isn't running, start it
                    if (!statusUpdateInterval) {
                        startStatusPolling();
                    }
                    
                    return data;
                } catch (error) {
                    console.error('Error fetching scheduled messages:', error);
                    return { total: 0, messages: [] };
                }
            }

            // Function to update the next message countdown in real-time
            function startNextMessageCountdown() {
                // Clear any existing timer
                if (window.nextMessageTimer) {
                    clearInterval(window.nextMessageTimer);
                }
                
                // Get the next message element
                const nextMessageElement = document.getElementById('next-message');
                if (!nextMessageElement) return;
                
                // Start a timer to update the countdown every second
                window.nextMessageTimer = setInterval(() => {
                    // Check if there's data in the element
                    const content = nextMessageElement.innerHTML;
                    if (!content || content.includes('No more scheduled messages')) return;
                    
                    // Try to extract the scheduled time
                    const timeMatch = content.match(/at <strong>(\d+:\d+)<\/strong>/);
                    if (!timeMatch) return;
                    
                    // Parse the time
                    const [hours, minutes] = timeMatch[1].split(':').map(num => parseInt(num, 10));
                    const scheduledTime = new Date();
                    scheduledTime.setHours(hours, minutes, 0, 0);
                    
                    // If time is in the past (earlier today), set to tomorrow
                    const now = new Date();
                    if (scheduledTime < now && scheduledTime.getHours() < now.getHours()) {
                        scheduledTime.setDate(scheduledTime.getDate() + 1);
                    }
                    
                    // Calculate time remaining
                    const timeUntil = scheduledTime - now;
                    
                    // Update the countdown portion of the message
                    if (timeUntil <= 0) {
                        // Replace the countdown part with "Sending now..."
                        nextMessageElement.innerHTML = nextMessageElement.innerHTML.replace(
                            /\([^)]+\)/,
                            '(<span class="pulse-strong">Sending now...</span>)'
                        );
                    } else {
                        // Update with a new formatted time
                        const formatted = formatDuration(timeUntil);
                        nextMessageElement.innerHTML = nextMessageElement.innerHTML.replace(
                            /\([^)]+\)/,
                            `(${formatted})`
                        );
                    }
                }, 1000);
            }

            // Connect WhatsApp button click
            connectBtn.addEventListener('click', async function() {
                // Disable button to prevent multiple clicks
                connectBtn.disabled = true;
                
                try {
                    statusMessage.textContent = 'Initializing WhatsApp...';
                    statusMessage.className = 'status';
                    
                    console.log('Sending request to initialize WhatsApp...');
                    
                    // Initialize WhatsApp
                    const response = await fetch('/init-whatsapp');
                    console.log('Received response from server', response.status);
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'Failed to initialize WhatsApp');
                    }
                    
                    const data = await response.json();
                    console.log('Parsed data:', data);
                    
                    if (data.qrCode) {
                        console.log('QR code received, showing for scanning');
                        qrCode.src = data.qrCode;
                        qrContainer.style.display = 'block';
                        statusMessage.textContent = 'Scan this QR code with WhatsApp on your phone';
                        
                        // Start polling for session status and QR code
                        pollForSession();
                    } else if (data.message) {
                        console.log('Message received:', data.message);
                        statusMessage.textContent = data.message;
                        await checkSession();
                    }
                } catch (error) {
                    console.error('Error in WhatsApp initialization:', error);
                    statusMessage.textContent = error.message || 'Error initializing WhatsApp. Please try again.';
                    statusMessage.className = 'status error';
                } finally {
                    // Re-enable button after all operations
                    setTimeout(() => {
                        connectBtn.disabled = false;
                    }, 2000); // 2-second delay to prevent spam clicks
                }
            });

            // Schedule toggle change event
            scheduleToggle.addEventListener('change', function() {
                if (this.checked) {
                    document.getElementById('custom-schedule-options').style.display = 'block';
                } else {
                    document.getElementById('custom-schedule-options').style.display = 'none';
                }
            });
            
            // Stop schedule button click
            stopScheduleBtn.addEventListener('click', async function() {
                try {
                    stopScheduleBtn.disabled = true;
                    stopScheduleBtn.textContent = 'Stopping...';
                    
                    const response = await fetch('/stop-schedule');
                    const data = await response.json();
                    
                    console.log('Schedule stopped:', data);
                    
                    stopScheduleBtn.textContent = 'Schedule Stopped';
                    
                    // Update UI to reflect that schedule is stopped
                    const notification = document.createElement('div');
                    notification.className = 'alert alert-warning';
                    notification.textContent = `Schedule stopped. ${data.remainingScheduled} messages will not be sent.`;
                    
                    // Insert notification above the scheduled info container
                    const scheduledInfo = document.getElementById('scheduled-info');
                    scheduledInfo.parentNode.insertBefore(notification, scheduledInfo);
                    
                    // Auto-dismiss after 10 seconds
                    setTimeout(() => {
                        notification.style.display = 'none';
                    }, 10000);
                    
                } catch (error) {
                            console.error('Error stopping schedule:', error);
                    stopScheduleBtn.disabled = false;
                    stopScheduleBtn.textContent = 'Stop Schedule';
                    
                    alert('Failed to stop schedule: ' + error.message);
                }
            });

            // Poll for session and update QR code if needed
            function pollForSession() {
                const sessionInterval = setInterval(async function() {
                    const status = await checkSession();
                    
                    if (status === 'connected') {
                        clearInterval(sessionInterval);
                        qrContainer.style.display = 'none';
                    } else {
                        // Try to get new QR code if not connected
                        try {
                            const response = await fetch('/get-qrcode');
                            if (response.ok) {
                                const data = await response.json();
                                if (data.qrCode && data.qrCode !== qrCode.src) {
                                    qrCode.src = data.qrCode;
                                }
                            }
                        } catch (error) {
                            console.error('Error fetching QR code:', error);
                        }
                    }
                }, 3000);
                
                // Stop polling after 2 minutes
                setTimeout(() => {
                    clearInterval(sessionInterval);
                }, 120000);
            }

            // Logout button click
            logoutBtn.addEventListener('click', async function() {
                try {
                    const response = await fetch('/logout');
                    const data = await response.json();
                    
                    statusMessage.textContent = data.message;
                    checkSession();
                    
                    // Hide results
                    resultsDiv.style.display = 'none';
                    progressContainer.style.display = 'none';
                    
                    // Stop status polling
                    if (statusUpdateInterval) {
                        clearInterval(statusUpdateInterval);
                        statusUpdateInterval = null;
                    }
                } catch (error) {
                    console.error('Error:', error);
                    statusMessage.textContent = 'Error logging out. Please try again.';
                    statusMessage.className = 'status error';
                }
            });

            // Form submission for sending messages
            messageForm.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                // Reset flag
                isAborted = false;
                
                // Get form data
                const formData = new FormData(this);
                
                // Check if file and message are provided
                const fileInput = document.getElementById('numbersFile');
                const messageInput = document.getElementById('message');
                const durationInput = document.getElementById('schedule-duration');
                
                if (!fileInput.files.length) {
                    alert('Please select a file with phone numbers');
                    return;
                }
                
                if (!messageInput.value.trim()) {
                    alert('Please enter a message to send');
                    return;
                }
                
                try {
                    // Show progress container and hide other elements
                    statusMessage.style.display = 'none';
                    messageForm.style.display = 'none';
                    progressContainer.style.display = 'block';
                    resultsDiv.style.display = 'none';
                    
                    // Initialize progress display
                    resetProgressDisplay();
                    
                    // Check if we're in schedule mode
                    isScheduleMode = scheduleToggle.checked;
                    
                    // Ensure duration is set (default 24 hours if not specified)
                    if (isScheduleMode) {
                        // Set duration to input value or default to 24
                        const duration = durationInput.value ? parseInt(durationInput.value) : 24;
                        
                        // Validate the duration is between 1 and 168 hours
                        const validDuration = Math.min(Math.max(duration, 1), 168);
                        
                        // Update the form data with validated duration
                        formData.set('scheduleDuration', validDuration.toString());
                        
                        // Show schedule UI elements
                        document.getElementById('scheduled-info').style.display = 'block';
                        scheduledColumn.style.display = 'block';
                        stopScheduleBtn.disabled = false;
                        stopScheduleBtn.textContent = 'Stop Schedule';
                    } else {
                        // Hide schedule UI elements
                        document.getElementById('scheduled-info').style.display = 'none';
                        scheduledColumn.style.display = 'none';
                    }
                    
                    // Send the messages
                    const response = await fetch('/send-messages', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'Failed to send messages');
                    }
                    
                    const data = await response.json();
                    
                    // Set the initial total count
                    totalCount.textContent = data.totalNumbers;
                    scheduledCount.textContent = data.totalNumbers;
                    
                    // Start polling for status updates
                    startStatusPolling();
                    
                } catch (error) {
                    console.error('Error:', error);
                    currentNumber.textContent = 'Process failed';
                    statusMessage.style.display = 'block';
                    statusMessage.textContent = error.message || 'Error sending messages. Please try again.';
                    statusMessage.className = 'status error';
                    messageForm.style.display = 'block';
                }
            });

            // Start polling for status
            function startStatusPolling() {
                // Clear any existing interval
                if (statusUpdateInterval) {
                    clearInterval(statusUpdateInterval);
                }
                
                // Poll more frequently for better real-time updates
                statusUpdateInterval = setInterval(pollMessageStatus, 300); // Poll every 300ms for more responsive updates
                
                // Run immediately on start
                pollMessageStatus();
                
                // Set a maximum polling time
                setTimeout(() => {
                    if (statusUpdateInterval) {
                        clearInterval(statusUpdateInterval);
                        statusUpdateInterval = null;
                    }
                }, 24 * 60 * 60 * 1000); // 24 hours max
            }

            // Function to poll for message sending status
            async function pollMessageStatus() {
                try {
                    if (document.hidden) {
                        console.log('Document is hidden, pausing status polling');
                        return;
                    }
                    
                    console.log('Polling for message status...');
                    const response = await fetch('/message-status');
                    
                    if (!response.ok) {
                        console.error('Failed to get message status:', response.statusText);
                        return;
                    }
                    
                    const data = await response.json();
                    console.log('Received message status data:', data);
                    
                    // Store the entire sending results in localStorage for persistence
                    localStorage.setItem('sendingResults', JSON.stringify(data));
                    localStorage.setItem('lastStatusUpdate', new Date().getTime());
                    
                    // Always show progress container when we have any data
                    if (data.total > 0 || data.success?.length > 0 || data.failed?.length > 0 || 
                        (data.scheduleInfo && data.scheduleInfo.upcomingMessages?.length > 0)) {
                        progressContainer.style.display = 'block';
                    }
                    
                    // Update status lists for success and failed
                    updateStatusLists(data);
                    
                    // Update total, success, and failure counts
                    totalCount.textContent = data.total || '0';
                    
                    // Always update success and failure counts and make columns visible if there's data
                    const successColumnCount = data.success ? data.success.length : 0;
                    successCount.textContent = successColumnCount;
                    if (successColumnCount > 0) {
                        const successColumn = document.getElementById('success-column');
                        if (successColumn) successColumn.style.display = 'block';
                    }
                    
                    const failedColumnCount = data.failed ? data.failed.length : 0;
                    failedCount.textContent = failedColumnCount;
                    if (failedColumnCount > 0) {
                        const failedColumn = document.getElementById('failed-column');
                        if (failedColumn) failedColumn.style.display = 'block';
                    }
                    
                    // If we have a current processing number, update the display
                    if (data.current) {
                        // Parse the current number
                        let displayNumber = '';
                        let statusPrefix = '';
                        
                        if (data.current.includes(':')) {
                            const parts = data.current.split(':');
                            statusPrefix = parts[0].trim();
                            let remaining = parts[1].trim();
                            if (remaining.includes('(')) {
                                displayNumber = remaining.substring(0, remaining.indexOf('(')).trim();
                            } else {
                                displayNumber = remaining;
                            }
                        } else {
                            displayNumber = data.current;
                            statusPrefix = 'Processing';
                        }
                        
                        // Apply appropriate styling based on status prefix
                        let statusClass = '';
                        switch (statusPrefix.toLowerCase()) {
                            case 'processing':
                                statusClass = 'processing-active';
                                break;
                            case 'next':
                                statusClass = 'next-active';
                                break;
                            case 'scheduled':
                                statusClass = 'scheduled-active';
                                break;
                            case 'processing soon':
                                statusClass = 'imminent-active';
                                break;
                            case 'completed':
                                statusClass = 'completed-active';
                                break;
                            default:
                                statusClass = 'processing-active';
                        }
                        
                        // Update UI with the current number
                        currentNumber.innerHTML = `${statusPrefix}: <span class="current-processing-number ${statusClass}">${displayNumber}</span>`;
                        currentNumber.classList.add('processing-active');
                        
                        // Update page title to show what's happening
                        document.title = `${statusPrefix}: ${displayNumber} - WhatsApp Bulk Messenger`;
                    } else {
                        // If no current number, show "None" with appropriate styling
                        currentNumber.innerHTML = 'Processing: <span class="current-processing-number">None</span>';
                        currentNumber.classList.remove('processing-active');
                        document.title = 'WhatsApp Bulk Messenger';
                    }
                    
                    // Check for scheduling mode
                    if (data.scheduleInfo) {
                        // Show scheduled info section
                        document.getElementById('scheduled-info').style.display = 'block';
                        
                        // Make scheduled column visible
                        const scheduledColumn = document.getElementById('scheduled-column');
                        if (scheduledColumn) scheduledColumn.style.display = 'block';
                        
                        // Create schedule display data from the response
                        const scheduleDisplayData = {
                            active: true,
                            startTime: data.scheduleInfo.startTime,
                            endTime: data.scheduleInfo.endTime,
                            upcomingMessages: data.scheduleInfo.upcomingMessages || []
                        };
                        
                        // Update the scheduled display
                        updateScheduleDisplay(scheduleDisplayData);
                        
                        // Update the upcoming messages list
                        if (data.scheduleInfo.upcomingMessages && data.scheduleInfo.upcomingMessages.length > 0) {
                            updateUpcomingMessagesList(data.scheduleInfo.upcomingMessages);
                        }
                        
                        // Update scheduled count
                        if (data.scheduled) {
                            const scheduledItems = data.scheduled.filter(item => item.status === 'scheduled');
                            scheduledCount.textContent = scheduledItems.length;
                        }
                    } else {
                        // Regular mode - update progress bar
                        if (data.total > 0) {
                            const progress = Math.round((data.processed / data.total) * 100) || 0;
                            progressBar.style.width = `${progress}%`;
                            progressBar.textContent = `${progress}%`;
                            progressText.textContent = `${data.processed}/${data.total} (${progress}%)`;
                            
                            // Update scheduled count (remaining to process)
                            scheduledCount.textContent = data.processed < data.total ? (data.total - data.processed) : '0';
                        }
                    }
                    
                    // Check if messages are still processing or all done
                    if (data.total === 0 || data.processed >= data.total) {
                        // Processing complete
                        if (!data.scheduleInfo || (data.scheduleInfo && data.scheduleInfo.upcomingMessages.length === 0)) {
                            // No scheduled messages remaining, show the message form
                            messageForm.style.display = 'block';
                        }
                    } else {
                        // Still processing, hide the message form
                        messageForm.style.display = 'none';
                    }
                } catch (error) {
                    console.error('Error polling for message status:', error);
                }
            }

            // Update schedule display with current status - improved for real-time updates
            function updateScheduleDisplay(data) {
                const scheduleInfo = document.getElementById('schedule-info');
                const scheduledMessages = document.getElementById('scheduled-messages');

                // Always show schedule info if we have upcoming messages, regardless of active state
                if (data.active || (data.upcomingMessages && data.upcomingMessages.length > 0)) {
                    // Make sure schedule-container exists (added as failsafe)
                    const scheduleContainer = document.getElementById('schedule-container');
                    if (scheduleContainer) {
                        scheduleContainer.style.display = 'block';
                    }
                    
                    scheduleInfo.style.display = 'block';
                    scheduleInfo.innerHTML = `<div class="alert alert-info">
                        <strong>Schedule Active</strong> - ${data.startTime ? 'Started at ' + data.startTime : 'Current Time'}<br>
                        <span id="next-message" class="next-message-info"></span>
                    </div>`;
                    
                    const stopScheduleBtn = document.getElementById('stop-schedule');
                    if (stopScheduleBtn) {
                        stopScheduleBtn.style.display = 'inline-block';
                        stopScheduleBtn.textContent = 'Stop Schedule';
                        stopScheduleBtn.disabled = false;
                    }
                    
                    // Update upcoming messages list if we have messages
                    if (data.upcomingMessages && data.upcomingMessages.length > 0) {
                        updateUpcomingMessagesList(data.upcomingMessages);
                        
                        // Show next message info with dynamic countdown
                        const nextMessage = data.upcomingMessages[0];
                        const now = new Date();
                        const scheduledTime = new Date(nextMessage.scheduledTime);
                        const timeUntil = scheduledTime - now;
                        
                        const formattedTime = scheduledTime.getHours().toString().padStart(2, '0') + ':' + 
                                         scheduledTime.getMinutes().toString().padStart(2, '0');
                        
                        const nextMessageElement = document.getElementById('next-message');
                        if (nextMessageElement) {
                            const timeUntilFormatted = formatDuration(timeUntil);
                            
                            // Add imminent class for visual indication if sending soon
                            if (timeUntil < 60000) { // less than a minute
                                nextMessageElement.classList.add('imminent');
                            } else {
                                nextMessageElement.classList.remove('imminent');
                            }
                            
                            // The property might be 'phoneNumber' or 'number' depending on data source
                            const phoneNumber = nextMessage.phoneNumber || nextMessage.number || 'Unknown';
                            nextMessageElement.innerHTML = `Next message to <strong>${phoneNumber}</strong> at <strong>${formattedTime}</strong> (${timeUntilFormatted})`;
                        }
                    } else {
                        const nextMessageElement = document.getElementById('next-message');
                        if (nextMessageElement) {
                            nextMessageElement.innerHTML = 'No more scheduled messages';
                        }
                    }
                } else {
                    scheduleInfo.style.display = 'none';
                    if (scheduledMessages) {
                        scheduledMessages.innerHTML = '';
                    }
                    
                    const stopScheduleBtn = document.getElementById('stop-schedule');
                    if (stopScheduleBtn) {
                        stopScheduleBtn.style.display = 'none';
                    stopScheduleBtn.textContent = 'Schedule Stopped';
                }
                }
                
                // Start the next message countdown timer for real-time updates
                startNextMessageCountdown();
            }

            // Update scheduled list display
            function updateScheduledList(scheduledItems) {
                if (!scheduledItems || scheduledItems.length === 0) return;
                
                // Get current items
                const currentItems = scheduledList.querySelectorAll('.scheduled-item, .success-item, .failed-item');
                const currentCount = currentItems.length;
                
                // If we have fewer items, we need to add them
                if (currentCount < scheduledItems.length) {
                    for (let i = currentCount; i < scheduledItems.length; i++) {
                        const item = scheduledItems[i];
                        addItemToScheduledList(item);
                    }
                }
            }
            
            // Format duration in a human-readable way
            function formatDuration(ms) {
                if (ms < 0) return 'Scheduled for now';
                
                const seconds = Math.floor((ms / 1000) % 60);
                const minutes = Math.floor((ms / (1000 * 60)) % 60);
                const hours = Math.floor(ms / (1000 * 60 * 60));
                
                let result = '';
                if (hours > 0) result += `${hours}h `;
                if (minutes > 0 || hours > 0) result += `${minutes}m `;
                result += `${seconds}s`;
                
                return result;
            }

            // Update success and failure lists with real-time animation
            function updateStatusLists(status) {
                // Update success list
                if (status.success && status.success.length > 0) {
                    // Clear list if it gets too large to prevent browser slowdown
                    if (successList.children.length > 50) {
                        successList.innerHTML = '';
                    }
                    
                    // Add new items with animation
                    for (let i = successList.children.length; i < status.success.length; i++) {
                        const result = status.success[i];
                        const successItem = document.createElement('div');
                        successItem.className = 'status-item success-item';
                        
                        // Add timestamp for better tracking
                        const timestamp = new Date(result.timestamp);
                        const timeStr = timestamp.toLocaleTimeString();
                        
                        successItem.innerHTML = `<strong>${result.number}</strong>: Message sent successfully <span class="time-stamp">(${timeStr})</span>`;
                        
                        // Add opacity animation
                        successItem.style.opacity = '0';
                        successList.appendChild(successItem);
                        
                        // Trigger animation
                        setTimeout(() => {
                            successItem.style.opacity = '1';
                            successItem.style.transition = 'opacity 0.3s ease-in';
                        }, 10);
                    }
                    
                    // Scroll to bottom to show latest messages
                    successList.scrollTop = successList.scrollHeight;
                }
                
                // Update failure list
                if (status.failed && status.failed.length > 0) {
                    // Clear list if it gets too large
                    if (failedList.children.length > 50) {
                        failedList.innerHTML = '';
                    }
                    
                    // Add new items with animation
                    for (let i = failedList.children.length; i < status.failed.length; i++) {
                        const result = status.failed[i];
                        const failedItem = document.createElement('div');
                        failedItem.className = 'status-item failed-item';
                        
                        // Add timestamp for better tracking
                        const timestamp = new Date(result.timestamp);
                        const timeStr = timestamp.toLocaleTimeString();
                        
                        failedItem.innerHTML = `<strong>${result.number}</strong>: ${result.error || 'Failed to send message'} <span class="time-stamp">(${timeStr})</span>`;
                        
                        // Add opacity animation
                        failedItem.style.opacity = '0';
                        failedList.appendChild(failedItem);
                        
                        // Trigger animation
                        setTimeout(() => {
                            failedItem.style.opacity = '1';
                            failedItem.style.transition = 'opacity 0.3s ease-in';
                        }, 10);
                    }
                    
                    // Scroll to bottom to show latest messages
                    failedList.scrollTop = failedList.scrollHeight;
                }
                
                // Update scheduled list if present
                if (status.scheduled && status.scheduled.length > 0) {
                    // Make sure scheduled column is visible
                    scheduledColumn.style.display = 'block';
                    
                    // Update scheduled list
                    updateScheduledList(status.scheduled);
                }
            }

            // Format time (HH:MM)
            function formatTime(date) {
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }
            
            // Format relative time for better readability
            function getRelativeTimeString(date) {
                const now = new Date();
                const diffMs = date - now;
                
                if (diffMs < 0) {
                    return 'Passed';
                }
                
                const diffSecs = Math.floor(diffMs / 1000);
                const diffMins = Math.floor(diffSecs / 60);
                const diffHours = Math.floor(diffMins / 60);
                
                if (diffHours > 0) {
                    return `in ${diffHours}h ${diffMins % 60}m`;
                } else if (diffMins > 0) {
                    return `in ${diffMins}m`;
                } else {
                    return `in ${diffSecs}s`;
                }
            }
            
            // Format phone number for display
            function formatPhoneNumber(number) {
                // Basic formatting, can be adjusted based on your requirements
                const cleaned = ('' + number).replace(/\D/g, '');
                const match = cleaned.match(/^(\d{1,3})(\d{0,3})(\d{0,4})$/);
                if (match) {
                    return match[1] + (match[2] ? '-' + match[2] : '') + (match[3] ? '-' + match[3] : '');
                }
                return number;
            }

            // Reset progress display
            function resetProgressDisplay() {
                progressBar.style.width = '0%';
                progressBar.textContent = '0%';
                progressText.textContent = '0/0 (0%)';
                currentNumber.textContent = 'Processing: Starting...';
                totalCount.textContent = '0';
                successCount.textContent = '0';
                failedCount.textContent = '0';
                scheduledCount.textContent = '0';
                successList.innerHTML = '';
                failedList.innerHTML = '';
                scheduledList.innerHTML = '';
                nextMessage.textContent = 'Next message in: --:--:--';
                timeProgress.style.width = '0%';
                startTime.textContent = 'Start';
                endTime.textContent = 'End';
                
                // Reset scheduled info heading
                const scheduledInfoHeading = document.querySelector('#scheduled-info h3');
                if (scheduledInfoHeading) {
                    scheduledInfoHeading.textContent = 'Scheduled Messages Status';
                }
            }

            // Finish sending process
            function finishSending(reason) {
                let statusText = '';
                let statusClass = '';
                
                const totalSuccessCount = parseInt(successCount.textContent) || 0;
                const totalFailedCount = parseInt(failedCount.textContent) || 0;
                
                switch (reason) {
                    case 'completed':
                        statusText = `Completed: ${totalSuccessCount} sent, ${totalFailedCount} failed`;
                        statusClass = 'status success';
                        currentNumber.textContent = 'Processing: Completed';
                        
                        // Delete all data after completion
                        cleanupAfterCompletion();
                        break;
                        
                    case 'aborted':
                        statusText = 'Message sending was aborted';
                        statusClass = 'status error';
                        currentNumber.textContent = 'Process aborted';
                        break;
                        
                    case 'timeout':
                        statusText = 'Message sending timed out';
                        statusClass = 'status error';
                        currentNumber.textContent = 'Process timed out';
                        break;
                }
                
                // Update pending count to 0
                scheduledCount.textContent = '0';
                
                // Show message form again
                setTimeout(() => {
                    messageForm.style.display = 'block';
                    statusMessage.style.display = 'block';
                    statusMessage.textContent = statusText;
                    statusMessage.className = statusClass;
                }, 2000);
            }

            // Comprehensive cleanup function
            async function cleanupAfterCompletion() {
                console.log('Performing complete data cleanup after sending');
                
                try {
                    // 1. Delete the uploaded file
                    await deleteUploadedFile();
                    
                    // 2. Clear any scheduled messages
                    if (isScheduleMode) {
                        await fetch('/stop-schedule')
                            .then(response => response.json())
                            .catch(error => {
                                console.error('Error stopping schedule:', error);
                            });
                    }
                    
                    // 3. Clear all in-memory data
                    sendingResults = {
                        success: [],
                        failed: [],
                        scheduled: [],
                        current: null,
                        total: 0,
                        processed: 0
                    };
                    
                    // 4. Reset UI elements
                    scheduledMessagesCard.style.display = 'none';
                    scheduledMessagesList.innerHTML = '';
                    scheduledMessagesCount.textContent = '0';
                    
                    // Reset upcoming messages
                    const upcomingMessagesList = document.getElementById('upcoming-messages-list');
                    if (upcomingMessagesList) {
                        upcomingMessagesList.innerHTML = '<div class="text-muted">No scheduled messages</div>';
                    }
                    
                    // Timeline reset
                    const messagePoints = document.getElementById('messagePoints');
                    if (messagePoints) {
                        messagePoints.innerHTML = '';
                    }
                    
                    // Reset statistics
                    document.getElementById('morningCount').textContent = '0';
                    document.getElementById('afternoonCount').textContent = '0';
                    document.getElementById('eveningCount').textContent = '0';
                    document.getElementById('nightCount').textContent = '0';
                    
                    // 5. Show confirmation to user
                    const notification = document.createElement('div');
                    notification.className = 'alert alert-success mt-2';
                    notification.innerHTML = `<strong>All data cleared!</strong> Messages have been sent and all associated data has been deleted.`;
                    notification.style.position = 'fixed';
                    notification.style.top = '20px';
                    notification.style.right = '20px';
                    notification.style.zIndex = '9999';
                    notification.style.boxShadow = '0 4px 8px rgba(0,0,0,0.1)';
                    document.body.appendChild(notification);
                    
                    // Remove notification after a few seconds
                    setTimeout(() => {
                        notification.style.opacity = '0';
                        notification.style.transition = 'opacity 0.5s';
                        setTimeout(() => {
                            document.body.removeChild(notification);
                        }, 500);
                    }, 5000);
                    
                    console.log('Data cleanup complete');
                } catch (error) {
                    console.error('Error during data cleanup:', error);
                }
            }

            // Function to delete the uploaded file after sending completion
            async function deleteUploadedFile() {
                try {
                    const response = await fetch('/delete-uploaded-file', {
                        method: 'POST'
                    });
                    
                    if (!response.ok) {
                        console.error('Failed to delete uploaded file');
                    } else {
                        console.log('Uploaded file deleted successfully');
                    }
                } catch (error) {
                    console.error('Error deleting uploaded file:', error);
                }
            }

            // Function to check session status
            async function checkSession() {
                try {
                    console.log('Checking WhatsApp session status...');
                    const response = await fetch('/check-session');
                    
                    if (!response.ok) {
                        throw new Error('Failed to check session status');
                    }
                    
                    const data = await response.json();
                    console.log('Session status:', data.status);
                    
                    if (data.status === 'connected') {
                        statusMessage.textContent = 'Connected to WhatsApp';
                        statusMessage.className = 'status success';
                        connectBtn.style.display = 'none';
                        logoutBtn.style.display = 'inline-block';
                        messageForm.style.display = 'block';
                        qrContainer.style.display = 'none';
                    } else {
                        statusMessage.textContent = 'Not connected to WhatsApp';
                        statusMessage.className = 'status';
                        connectBtn.style.display = 'inline-block';
                        logoutBtn.style.display = 'none';
                        messageForm.style.display = 'none';
                    }
                    
                    return data.status;
                } catch (error) {
                    console.error('Error checking session:', error);
                    statusMessage.textContent = 'Error checking connection status';
                    statusMessage.className = 'status error';
                    return 'error';
                }
            }

            // Display scheduled messages in the UI
            function displayScheduledMessages(data) {
                console.log('displayScheduledMessages called with data:', data);
                
                // Check if any scheduled messages are returned
                if (!data || !data.messages || data.messages.length === 0) {
                    console.log('No scheduled messages to display');
                    scheduledMessagesCard.style.display = 'none';
                    scheduledMessagesList.innerHTML = '<div class="text-center text-muted">No scheduled messages</div>';
                    
                    // Clear timeline visualization
                    const messagePoints = document.getElementById('messagePoints');
                    if (messagePoints) messagePoints.innerHTML = '';
                    
                    // Reset counts
                    document.getElementById('morningCount').textContent = '0';
                    document.getElementById('afternoonCount').textContent = '0';
                    document.getElementById('eveningCount').textContent = '0';
                    document.getElementById('nightCount').textContent = '0';
                    
                    return;
                }
                
                console.log(`Displaying ${data.messages.length} scheduled messages`);
                
                // Show the card
                scheduledMessagesCard.style.display = 'block';
                
                // Update count
                scheduledMessagesCount.textContent = data.total;
                
                // Clear existing list
                scheduledMessagesList.innerHTML = '';
                
                // Also update the upcoming messages list
                updateUpcomingMessagesList(data.messages);
                
                // Make sure we have start and end times for timeline
                if (data.startTime && data.endTime) {
                    console.log(`Schedule range: ${new Date(data.startTime).toLocaleString()} to ${new Date(data.endTime).toLocaleString()}`);
                    // Update the timeline visualization
                    updateScheduleTimeline(data.messages, data.startTime, data.endTime);
                } else {
                    console.warn('Missing start or end time for timeline visualization');
                    // Try to calculate timerange from the scheduled messages
                    if (data.messages.length > 0) {
                        const times = data.messages.map(m => new Date(m.scheduledTime).getTime());
                        const earliestTime = new Date(Math.min(...times));
                        const latestTime = new Date(Math.max(...times));
                        
                        // Add some padding
                        earliestTime.setHours(earliestTime.getHours() - 1);
                        latestTime.setHours(latestTime.getHours() + 1);
                        
                        console.log(`Calculated time range: ${earliestTime.toLocaleString()} to ${latestTime.toLocaleString()}`);
                        updateScheduleTimeline(data.messages, earliestTime.toISOString(), latestTime.toISOString());
                    }
                }
                
                // Add each message to the list
                data.messages.forEach((item, index) => {
                    const scheduledTime = new Date(item.scheduledTime);
                    const listItem = document.createElement('div');
                    listItem.className = 'list-group-item d-flex justify-content-between align-items-center';
                    listItem.innerHTML = `
                        <div>
                            <strong>${item.number}</strong>
                            <br>
                            <small class="text-muted">${formatTime(scheduledTime)} (${getRelativeTimeString(scheduledTime)})</small>
                        </div>
                        <button class="btn btn-sm btn-outline-danger cancel-btn" data-id="${item.id}">Cancel</button>
                    `;
                    
                    // Add a max height for long lists
                    if (index >= 10 && index === data.messages.length - 1) {
                        scheduledMessagesList.style.maxHeight = '300px';
                        scheduledMessagesList.style.overflowY = 'auto';
                    }
                    
                    scheduledMessagesList.appendChild(listItem);
                });
                
                // Add event listeners to cancel buttons
                document.querySelectorAll('.cancel-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const messageId = this.getAttribute('data-id');
                        cancelScheduledMessage(messageId);
                    });
                });
            }
            
            // Cancel a scheduled message
            async function cancelScheduledMessage(messageId) {
                if (!confirm('Are you sure you want to cancel this scheduled message?')) {
                    return;
                }
                
                try {
                    console.log('Cancelling scheduled message:', messageId);
                    
                    const response = await fetch(`/scheduled-message/${messageId}`, {
                        method: 'DELETE'
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'Failed to cancel scheduled message');
                    }
                    
                    const data = await response.json();
                    console.log('Message cancelled:', data);
                    
                    // Refresh message list
                    fetchScheduledMessages();
                    
                    // Show success notification
                    const notification = document.createElement('div');
                    notification.className = 'alert alert-success mt-2';
                    notification.innerHTML = `Message to <strong>${data.cancelledMessage.number}</strong> has been cancelled`;
                    notification.style.position = 'fixed';
                    notification.style.top = '20px';
                    notification.style.right = '20px';
                    notification.style.zIndex = '9999';
                    notification.style.boxShadow = '0 4px 8px rgba(0,0,0,0.1)';
                    document.body.appendChild(notification);
                    
                    // Remove notification after a few seconds
                    setTimeout(() => {
                        notification.style.opacity = '0';
                        notification.style.transition = 'opacity 0.5s';
                        setTimeout(() => {
                            document.body.removeChild(notification);
                        }, 500);
                    }, 3000);
                    
                } catch (error) {
                    console.error('Error cancelling message:', error);
                    alert('Failed to cancel message: ' + error.message);
                }
            }
            
            // Add event listener to the refresh button
            refreshScheduleBtn.addEventListener('click', function() {
                fetchScheduledMessages().then(data => {
                    // Explicitly make sure timeline is visible
                    if (data && data.messages && data.messages.length > 0) {
                        const scheduleTimeline = document.getElementById('scheduleTimeline');
                        if (scheduleTimeline) {
                            scheduleTimeline.style.display = 'block';
                            
                            // Force a reflow to ensure the timeline is properly sized
                            setTimeout(() => {
                                // Re-render the timeline visualization after DOM has settled
                                if (data.startTime && data.endTime) {
                                    updateScheduleTimeline(data.messages, data.startTime, data.endTime);
                                }
                            }, 100);
                        }
                    }
                });
            });

            // Improve the updateUpcomingMessagesList function for real-time updates
            function updateUpcomingMessagesList(scheduledItems) {
                console.log('Updating upcoming messages list with', scheduledItems?.length || 0, 'items');
                
                // First ensure parent containers are visible
                document.getElementById('scheduled-info').style.display = 'block';
                const allMessagesStatus = document.querySelector('.all-messages-status');
                if (allMessagesStatus) {
                    allMessagesStatus.style.display = 'block';
                }
                
                const upcomingMessagesList = document.getElementById('upcoming-messages-list');
                if (!upcomingMessagesList) {
                    console.error('Could not find upcoming-messages-list element');
                    return;
                }
                
                // Make sure the container is visible
                upcomingMessagesList.style.display = 'block';
                
                // Clear the list
                upcomingMessagesList.innerHTML = '';
                
                // Normalize and filter scheduled items
                const pendingMessages = [];
                
                if (Array.isArray(scheduledItems)) {
                // Filter only scheduled (not sent/failed) messages
                    scheduledItems.forEach(item => {
                        if (!item.hasOwnProperty('status') || item.status === 'scheduled') {
                            pendingMessages.push(item);
                        }
                    });
                }
                
                if (pendingMessages.length === 0) {
                    upcomingMessagesList.innerHTML = '<div class="text-muted">No scheduled messages</div>';
                    return;
                }
                
                // Sort by scheduled time
                const sortedMessages = [...pendingMessages].sort((a, b) => {
                    return new Date(a.scheduledTime) - new Date(b.scheduledTime);
                });
                
                // Create table for better formatting
                const table = document.createElement('table');
                table.id = 'upcoming-messages-table';
                table.className = 'table table-sm table-striped upcoming-messages-table';
                table.innerHTML = `
                    <thead>
                        <tr>
                            <th width="25%">Time</th>
                            <th width="25%">Countdown</th>
                            <th width="50%">Phone Number</th>
                        </tr>
                    </thead>
                    <tbody id="upcoming-messages-tbody"></tbody>
                `;
                upcomingMessagesList.appendChild(table);
                
                const tbody = document.getElementById('upcoming-messages-tbody');
                
                // Current time for accurate countdowns
                const now = new Date();
                
                // Display all messages with real-time status
                sortedMessages.forEach((message, index) => {
                    const scheduledTime = new Date(message.scheduledTime);
                    const timeUntil = scheduledTime - now;
                    
                    // Format the countdown with special handling for imminent messages
                    const formattedTimeUntil = timeUntil <= 0 
                        ? '<span class="pulse">Sending now...</span>' 
                        : (message.formattedTimeUntil || formatDuration(timeUntil));
                    
                    // Create row with data attributes for real-time updates
                    const row = document.createElement('tr');
                    row.id = `msg-row-${index}`;
                    row.className = 'upcoming-message-row';
                    row.dataset.scheduledTime = scheduledTime.toISOString();
                    row.dataset.number = message.number || message.phoneNumber || '';
                    
                    // Add special class for messages that are about to be sent
                    if (timeUntil <= 60000) { // Less than a minute
                        row.classList.add('imminent');
                    } else if (timeUntil <= 300000) { // Less than 5 minutes
                        row.classList.add('very-soon');
                    }
                    
                    // Create cells with data
                    const timeCell = document.createElement('td');
                    timeCell.textContent = formatTime(scheduledTime);
                    
                    const countdownCell = document.createElement('td');
                    countdownCell.className = 'countdown-cell';
                    countdownCell.innerHTML = formattedTimeUntil;
                    
                    const numberCell = document.createElement('td');
                    numberCell.textContent = message.number || message.phoneNumber || 'Unknown';
                    
                    // Add cells to row
                    row.appendChild(timeCell);
                    row.appendChild(countdownCell);
                    row.appendChild(numberCell);
                    
                    // Add row to table
                    tbody.appendChild(row);
                });
                
                // Start or restart the countdown updater
                startCountdownUpdater();
            }

            // Function to update countdowns in real-time without waiting for server updates
            function startCountdownUpdater() {
                // Clear any existing updater
                if (window.countdownUpdater) {
                    clearInterval(window.countdownUpdater);
                }
                
                // Create new updater that runs every second
                window.countdownUpdater = setInterval(() => {
                    const tbody = document.getElementById('upcoming-messages-tbody');
                    if (!tbody) return;
                    
                    const rows = tbody.querySelectorAll('tr[data-scheduled-time]');
                    if (rows.length === 0) return;
                    
                    const now = new Date();
                    
                    // Update each row's countdown in real-time
                    rows.forEach(row => {
                        const scheduledTime = new Date(row.dataset.scheduledTime);
                        const timeUntil = scheduledTime - now;
                        const countdownCell = row.querySelector('.countdown-cell');
                        if (!countdownCell) return;
                        
                        // Update the countdown text
                        if (timeUntil <= 0) {
                            countdownCell.innerHTML = '<span class="pulse">Sending now...</span>';
                            row.className = 'upcoming-message-row imminent';
                    } else {
                            countdownCell.textContent = formatDuration(timeUntil);
                            
                            // Update row styling based on time remaining
                            row.className = 'upcoming-message-row';
                            if (timeUntil <= 60000) { // Less than a minute
                                row.classList.add('imminent');
                            } else if (timeUntil <= 300000) { // Less than 5 minutes
                                row.classList.add('very-soon');
                            }
                        }
                    });
                }, 1000); // Update every second
            }
        });
    </script>
</body>
</html>